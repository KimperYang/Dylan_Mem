{"task_id": "HumanEval/0", "completion": "    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to ensure closest elements are adjacent\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False\n"}
{"task_id": "HumanEval/1", "completion": "    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    \n    # Remove any spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    group_list = []\n    start = 0\n    balance = 0\n    \n    # Traverse through the string\n    for i in range(len(paren_string)):\n        # If a '(', increment balance\n        if paren_string[i] == '(':\n            balance += 1\n        # If a ')', decrement balance\n        elif paren_string[i] == ')':\n            balance -= 1\n        # If balance becomes 0, we have found a balanced parentheses group\n        if balance == 0:\n            group_list.append(paren_string[start:i+1])\n            start = i+1  # Move start to the next index\n        \n    return group_list\n"}
{"task_id": "HumanEval/2", "completion": "    \"\"\"\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number - int(number)\n"}
{"task_id": "HumanEval/3", "completion": "    \"\"\"\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n\n    return False\n"}
{"task_id": "HumanEval/4", "completion": "    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # First, calculate the mean of the input list\n    mean = sum(numbers)/len(numbers)\n    # Next, calculate the absolute differences from the mean\n    deviations = [abs(x - mean) for x in numbers]\n    # Finally, return the mean of these absolute differences\n    return sum(deviations)/len(deviations)\n"}
{"task_id": "HumanEval/5", "completion": "    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    result = []\n    for num in numbers:\n        result.append(num)\n        result.append(delimeter)\n    result = result[:-1]  # remove the last added delimeter\n    return result\n"}
{"task_id": "HumanEval/6", "completion": "    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    \n    # Split the string into groups of parentheses\n    groups = paren_string.split(' ')\n    \n    # Initialize an empty list for storing the depth of each group\n    depths = []\n    \n    # Loop through each group\n    for group in groups:\n        # Initialize the depth and max_depth to 0\n        depth = 0\n        max_depth = 0\n        \n        # For each character in the group\n        for char in group:\n            # If the character is '(' increase the depth\n            if char == '(':\n                depth += 1\n            # If the character is ')' decrease the depth\n            elif char == ')':\n                depth -= 1\n            \n            # If the current depth is greater than the max_depth, update the max_depth\n            if depth > max_depth:\n                max_depth = depth\n        \n        # Add the max_depth of the group to the depths list\n        depths.append(max_depth)\n        \n    # Return the depths list\n    return depths\n"}
{"task_id": "HumanEval/7", "completion": "    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    # Using list comprehension to filter strings\n    # The 'if substring in s' checks if the substring is present in each string\n    # Only the strings containing the substring are returned\n    return [s for s in strings if substring in s]\n"}
{"task_id": "HumanEval/8", "completion": "    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    # Initiate sum and product variables\n    sum_numbers, product_numbers = 0, 1\n\n    # Iterate over the numbers list and update the sum and the product\n    for number in numbers:\n        sum_numbers += number\n        product_numbers *= number\n    \n    # Return the sum and product as a tuple\n    return sum_numbers, product_numbers\n"}
{"task_id": "HumanEval/9", "completion": "    # Check if numbers list is empty\n    if not numbers:\n        return []\n\n    # Initialize max_num to first element and result list with first element\n    max_num = numbers[0]\n    result = [max_num]\n    \n    # Iterate over the rest of the numbers\n    for num in numbers[1:]:\n        # If current number is greater than max_num, update max_num\n        if num > max_num:\n            max_num = num\n            \n        # Append max_num to result\n        result.append(max_num)\n\n    return result"}
{"task_id": "HumanEval/10", "completion": "    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n\n    def find_longest_palindromic_suffix(string: str) -> int:\n        \"\"\" Find the longest palindromic suffix in the string \"\"\"\n        # Iterating backwards to find the longest palindromic suffix\n        for i in range(len(string), -1, -1):\n            # If substring is palindrome, return its length\n            if is_palindrome(string[-i:]):\n                return i\n        # If no palindromic suffix found, return 0\n        return 0\n\n    # Getting length of the longest palindromic suffix\n    length_of_suffix = find_longest_palindromic_suffix(string)\n\n    # If the whole string is a palindrome, return it\n    if length_of_suffix == len(string):\n        return string\n\n    # Get the part of the string before the palindromic suffix\n    prefix = string[:-length_of_suffix]\n\n    # Create the shortest palindrome by appending reversed prefix to the original string\n    return string + prefix[::-1]\n"}
{"task_id": "HumanEval/11", "completion": "    \"\"\"\n    Inputs are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n\n    # Check if input strings are of the same length\n    if len(a) != len(b):\n        raise ValueError('Input strings should be of the same length')\n\n    # Check if input strings contain only 1s and 0s\n    if not set(a).issubset({'0', '1'}) or not set(b).issubset({'0', '1'}):\n        raise ValueError('Input strings should only contain 1s and 0s')\n\n    # Perform XOR operation and return the result as a string\n    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n"}
{"task_id": "HumanEval/12", "completion": "    \"\"\" \n    Out of list of strings, return the longest one. \n    Return the first one in case of multiple strings of the same length. \n    Return None in case the input list is empty.\n    \"\"\"\n    # If the list is empty, return None\n    if not strings:\n        return None\n    \n    # Find the longest string\n    longest_string = max(strings, key=len)\n\n    # If there are multiple longest strings, return the first one\n    for string in strings:\n        if len(string) == len(longest_string):\n            return string\n\n# Test Cases\n\nassert longest([]) == None\nassert longest(['a', 'b', 'c']) == 'a'\nassert longest(['a', 'bb', 'ccc']) == 'ccc'\n"}
{"task_id": "HumanEval/13", "completion": "\n    # Using Euclidean Algorithm to find GCD\n    while(b): \n        a, b = b, a % b\n    return abs(a) # returning absolute value of a to ensure GCD is always positive"}
{"task_id": "HumanEval/14", "completion": "    # Initialize an empty list to store all the prefixes\n    prefixes = []\n    \n    # Use a for loop to get all the prefixes of the string\n    for i in range(1, len(string) + 1):\n        # Add each prefix to the list\n        prefixes.append(string[:i])\n        \n    # Return the list of prefixes\n    return prefixes"}
{"task_id": "HumanEval/15", "completion": "\n    return ' '.join(map(str, range(n + 1)))"}
{"task_id": "HumanEval/16", "completion": "    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case so that we do not count the same letter in upper case and lower case separately.\n    string = string.lower()\n    # Create a set from the string. A set in Python is a collection type that has no duplicate elements.\n    distinct_characters = set(string)\n    # Return the number of elements in the set. This is the number of distinct characters in the string.\n    return len(distinct_characters)\n"}
{"task_id": "HumanEval/17", "completion": "    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    \n    # splitting the music_string by space to get the list of notes\n    notes = music_string.split()\n    \n    # dictionary to hold the note to beats conversion\n    note_to_beats = {'o': 4, 'o|': 2, '.|': 1}\n    \n    # list to hold the number of beats for each note\n    beats = []\n    \n    # iterating over each note and adding the corresponding beats to the list\n    for note in notes:\n        beats.append(note_to_beats[note])\n    \n    return beats\n"}
{"task_id": "HumanEval/18", "completion": "\n    count = start = 0\n    while True:\n        start = string.find(substring, start) + 1\n        if start > 0:\n            count+=1\n        else:\n            return count"}
{"task_id": "HumanEval/19", "completion": "    \"\"\" Input is a space-delimited string of numerals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n\n    # Create a dictionary to map number names to their actual values\n    num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    # Split the input string into individual number names\n    num_list = numbers.split()\n\n    # Map the number names to their actual values and sort the resulting list\n    sorted_numbers = sorted(num_list, key=lambda x: num_dict[x])\n\n    # Join the sorted number names back into a string and return it\n    return ' '.join(sorted_numbers)\n"}
{"task_id": "HumanEval/20", "completion": "    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each \n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n\n    # Sort the given list of numbers\n    numbers.sort()\n    \n    # Define initial minimum difference as a large number\n    min_diff = float('inf')\n    \n    # Placeholder for the closest pair\n    closest_pair = None\n    \n    # Iterating over the sorted list and find the pair with minimum difference\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < min_diff:\n            min_diff = numbers[i+1] - numbers[i]\n            closest_pair = (numbers[i], numbers[i+1])\n    \n    return closest_pair\n"}
{"task_id": "HumanEval/21", "completion": "    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    \n    return [(x - min_val) / range_val for x in numbers]\n"}
{"task_id": "HumanEval/22", "completion": "    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    # Initialize an empty list for integers\n    integers = []\n    \n    # Iterate over the list of values\n    for value in values:\n        # Check if the value is of integer type\n        if isinstance(value, int):\n            # Append the integer to the list\n            integers.append(value)\n    \n    # Return the list of integers\n    return integers\n"}
{"task_id": "HumanEval/23", "completion": "\n    # Check if the input is of string type\n    if not isinstance(string, str):\n        raise ValueError(\"Input should be of string type\")\n\n    # Using the built-in len function to compute the length of the string\n    return len(string)"}
{"task_id": "HumanEval/24", "completion": "    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n\n    # Start iterating from n-1 and go down to 2, checking each number if it divides n evenly.\n    for divisor in range(n - 1, 1, -1):\n        if n % divisor == 0:\n            return divisor\n\n    # If no divisor smaller than n found, return 1 as by definition every integer is divisible by 1.\n    return 1\n"}
{"task_id": "HumanEval/25", "completion": "    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    \n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n"}
{"task_id": "HumanEval/26", "completion": "    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Initialize an empty dictionary to store the count of each number\n    count_dict = {}\n    \n    # Loop through each number in the input list\n    for number in numbers:\n        # If the number has not appeared before, add it to the result list\n        # and update the dictionary\n        if number not in count_dict:\n            result.append(number)\n            count_dict[number] = 1\n        # If the number has appeared before, remove it from the result list\n        elif number in result:\n            result.remove(number)\n            \n    return result\n"}
{"task_id": "HumanEval/27", "completion": "\n    return string.swapcase()"}
{"task_id": "HumanEval/28", "completion": "    \"\"\"\n    Concatenate list of strings into a single string\n    :param strings: List of strings\n    :return: A single string made by concatenating all strings in the list\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ''.join(strings)\n"}
{"task_id": "HumanEval/29", "completion": "    # Check if prefix is empty string, if true return all strings\n    if prefix == '':\n        return strings\n\n    # Otherwise, filter the list by checking if string starts with prefix\n    return [s for s in strings if s.startswith(prefix)]"}
{"task_id": "HumanEval/30", "completion": "\n    # Using list comprehension to filter out the positive numbers in the list\n    # The condition inside the list comprehension checks if the number is greater than 0\n    pos_list = [i for i in l if i > 0]\n    \n    return pos_list"}
{"task_id": "HumanEval/31", "completion": "    \"\"\"Return true if a given number is prime, and false otherwise.\n\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2: # 1 is not prime\n        return False\n    for i in range(2, int(n**0.5) + 1): # only need to check up to the square root of n\n        if n % i == 0: # if n is divisible by any number up to its square root, it's not prime\n            return False\n    return True\n"}
{"task_id": "HumanEval/32", "completion": "    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n\n    # Using scipy's fsolve function to find a root of the polynomial\n    # It requires a function, so we create a lambda function on the fly\n    # We also provide an initial guess of 0. fsolve will find the nearest root to this initial guess.\n    root = fsolve(lambda x: poly(xs, x), 0)[0]\n\n    return root\n"}
{"task_id": "HumanEval/33", "completion": "    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # collect the values at indices divisible by 3\n    third_indices_values = [l[i] for i in range(0, len(l), 3)]\n    \n    # sort these values\n    third_indices_values.sort()\n    \n    # replace the values at indices divisible by 3 with the sorted values\n    for i, val in enumerate(third_indices_values):\n        l[i * 3] = val\n    return l\n"}
{"task_id": "HumanEval/34", "completion": "\n    # Convert the list to a set to remove duplicates\n    unique_set = set(l)\n    \n    # Convert the set back to a list and sort it\n    unique_list = sorted(list(unique_set))\n    \n    return unique_list"}
{"task_id": "HumanEval/35", "completion": "\n    \n    # Check if list is empty\n    if not l:\n        return None\n    \n    # Initialize max_element as the first element of the list\n    max_element = l[0]\n    \n    # Iterate over the list\n    for element in l:\n        # If the current element is greater than the current max_element, update max_element\n        if element > max_element:\n            max_element = element\n    \n    return max_element"}
{"task_id": "HumanEval/36", "completion": "    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n    count_seven = 0\n\n    # Iterate over the range\n    for i in range(n):\n        # Check if i is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Check if 7 is in the digits of i\n            count_seven += str(i).count('7')\n            \n    return count_seven\n"}
{"task_id": "HumanEval/37", "completion": "\n    evens = sorted([x for i, x in enumerate(l) if i % 2 == 0])\n    for i, x in enumerate(l):\n        if i % 2 == 0:\n            l[i] = evens.pop(0)\n    return l"}
{"task_id": "HumanEval/38", "completion": "    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str) -> str:\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # split the encoded string into groups of 3 characters.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group in the reverse way of encoding. \n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n"}
{"task_id": "HumanEval/39", "completion": "    # Fibonacci sequence generation\n    fib = [0, 1]\n    while len(fib) < 2*n: \n        fib.append(fib[-1] + fib[-2])\n    \n    # Prime Fibonacci sequence generation\n    prime_fib = [x for x in fib if isprime(x)]\n    \n    return prime_fib[n-1]"}
{"task_id": "HumanEval/40", "completion": "\n    # Check if the list is less than 3\n    if len(l) < 3:\n        return False\n    else:\n        # Sort the list\n        l.sort()\n        for i in range(len(l)-2):\n            # Two pointers\n            start, end = i+1, len(l)-1\n            while start < end:\n                # If the sum is 0, we return True\n                if l[i] + l[start] + l[end] == 0:\n                    return True\n                # If the sum is negative, we need to increase it so we move the start pointer up\n                elif l[i] + l[start] + l[end] < 0:\n                    start += 1\n                # If the sum is positive, we need to decrease it so we move the end pointer down\n                else:\n                    end -= 1\n        # If no triple sum equals to zero\n        return False"}
{"task_id": "HumanEval/41", "completion": "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n    \n    This function outputs the number of such collisions.\n    \"\"\"\n    # Since every car moving from left to right will eventually collide with a car moving from right to left, \n    # the number of collisions will be equal to the number of cars moving in one direction.\n    return n\n"}
{"task_id": "HumanEval/42", "completion": "\n    # check if the input is a list\n    if not isinstance(l, list):\n        raise TypeError('Input should be a list')\n    # check if the list contains only integers\n    for i in l:\n        if not isinstance(i, int):\n            raise ValueError('List should contain only integers')\n    \n    # increment each element of the list by 1\n    return [i+1 for i in l]"}
{"task_id": "HumanEval/43", "completion": "\n\n    # Create a set\n    seen = set()\n    \n    for num in l:\n        # If the negative of the current number is in the set, return True\n        if -num in seen:\n            return True\n        # Otherwise, add the current number to the set\n        seen.add(num)\n    \n    return False"}
{"task_id": "HumanEval/44", "completion": "    \"\"\"\n    Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    \"\"\"\n    \n    # Import necessary package in the function body\n    import string\n    \n    # Define the conversion table\n    conversion_table = string.digits\n    \n    # Check if x is 0, if true return '0'\n    if x == 0:\n        return '0'\n    \n    # Check if base is not between 2 and 10\n    if base < 2 or base > 10:\n        return 'Error: Base must be between 2 and 10.'\n    \n    # Initialize the result\n    result = ''\n    \n    # Use while loop to keep dividing the number x by the base and append the remainder to the result\n    while x > 0:\n        result = conversion_table[x%base] + result\n        x = x // base\n        \n    return result\n"}
{"task_id": "HumanEval/45", "completion": "\n    return 0.5 * a * h"}
{"task_id": "HumanEval/46", "completion": "    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n    \n    # Initialize the base cases\n    fib = [0, 0, 2, 0]\n\n    # If n is less than 4, return the n-th fib4 number directly\n    if n < 4:\n        return fib[n]\n    \n    # Compute the rest of the sequence iteratively\n    for i in range(4, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])\n\n    # Return the n-th fib4 number\n    return fib[n]\n"}
{"task_id": "HumanEval/47", "completion": "\n    l.sort()\n    n = len(l)\n    if n % 2 == 0:\n        return (l[n//2] + l[n//2 - 1]) / 2\n    else:\n        return l[n//2]"}
{"task_id": "HumanEval/48", "completion": "    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    # Convert to lowercase and remove non-alphanumeric characters for more robust palindrome detection\n    text = ''.join(c for c in text if c.isalnum()).lower()\n    \n    # A string is a palindrome if it is equal to its reverse\n    return text == text[::-1]\n"}
{"task_id": "HumanEval/49", "completion": "\n    # The given task is to calculate (2^n) % p.\n    # Direct computation of 2^n could be very large for large n but python's pow function has an optimized implementation of this.\n    # It takes a third argument for the modulo operation that computes the answer more efficiently for large numbers.\n    # Note: the function checks if the second argument is non-zero to avoid ZeroDivisionError.\n    return pow(2, n, p) if p != 0 else 0"}
