{"task_id": "HumanEval/150", "completion": "\n\n    def is_prime(num):\n        \"\"\"Check if the given number is a prime number.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return x if is_prime(n) else y"}
{"task_id": "HumanEval/151", "completion": "    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n\n    If the input list is empty, return 0.\n    '''\n    \n    # Initialize a variable to hold the sum\n    sum_of_squares = 0\n\n    # Iterate over the list\n    for number in lst:\n        # Check if the current number is of integer type and is positive\n        if isinstance(number, int) and number >= 0:\n            # Check if the current number is odd\n            if number % 2 != 0:\n                # If it is, square it and add it to the sum\n                sum_of_squares += number ** 2\n\n    # Return the sum\n    return sum_of_squares\n"}
{"task_id": "HumanEval/152", "completion": "    \"\"\"\n    Determine if a person correctly guessed the results of a number of matches.\n    Given two arrays of scores and guesses of equal length, where each index shows a match. \n    Returns an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n    Args:\n    game : list of int : game results\n    guess : list of int : person's guesses\n\n    Returns:\n    list of int : absolute differences between guesses and actual results\n    \"\"\"\n    \n    # Using list comprehension to iterate over both lists simultaneously and calculate the absolute difference\n    return [abs(g - g_) for g, g_ in zip(game, guess)]\n"}
{"task_id": "HumanEval/153", "completion": "    \"\"\"\n    You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters\n    in the extension's name, the strength is given by the fraction CAP - SM.\n    You should find the strongest extension and return a string in this\n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n\n    # Initialize the strength to be a very small number\n    max_strength = float('-inf')\n    strongest_extension = ''\n\n    # iterate over the extensions\n    for extension in extensions:\n        # Calculate the strength of the extension\n        strength = sum(1 for c in extension if c.isupper()) - sum(1 for c in extension if c.islower())\n        \n        # If this extension is stronger or if it's the first one, update the strongest extension\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n\n    # return the strongest extension in the desired format\n    return '{}.{}'.format(class_name, strongest_extension)\n"}
{"task_id": "HumanEval/154", "completion": "    \"\"\"\n    You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word.\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    Parameters:\n    a (str): The first input word.\n    b (str): The second input word.\n\n    Returns:\n    bool: True if the second word or any of its rotations is a substring in the first word, False otherwise.\n    \"\"\"\n    # Rotating the second string for all possible positions\n    # and checking if it is substring in first string\n    for i in range(len(b)):\n        if b[i:] + b[:i] in a:\n            return True\n\n    return False\n"}
{"task_id": "HumanEval/155", "completion": "\n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Convert the absolute value of the number to string to iterate over digits\n    for digit in str(abs(num)):\n        # Increment respective counter depending on whether digit is even or odd\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Return a tuple with count of even and odd digits\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/156", "completion": "\n\n    # Define digit mapping\n    mapping = [(1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n               (100, 'c'),  (90, 'xc'),   (50, 'l'), (40, 'xl'),\n               (10, 'x'),   (9, 'ix'),    (5, 'v'),  (4, 'iv'),\n               (1, 'i')]\n\n    # Convert integer to roman numeral\n    result = ''\n    for i, numeral in mapping:\n        while number >= i:\n            result += numeral\n            number -= i\n\n    return result"}
{"task_id": "HumanEval/157", "completion": "    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is a right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n\n    # Sorting the sides so that the largest is last\n    # This is done because in a right-angled triangle,\n    # the square of the length of the largest side (hypotenuse) is equal to the sum of squares of the other two sides\n    sides = sorted([a, b, c])\n\n    # Check if the sum of the squares of the two smaller sides equals the square of the larger side\n    # If yes, return True, else return False\n    return sides[0]**2 + sides[1]**2 == sides[2]**2\n"}
{"task_id": "HumanEval/158", "completion": "\n\n    # First, we will ensure the list is not empty\n    if not words:\n        return None\n\n    # We will sort the list in lexicographical order. This is to ensure that if we have multiple words\n    # with the same number of unique characters, we return the one that comes first.\n    words.sort()\n\n    # Then we will initialize our maximum unique characters to be 0 and the word to be an empty string\n    max_unique_chars = 0\n    max_word = ''\n\n    # Now we will iterate over our list of words\n    for word in words:\n        # We will convert the word into a set. Sets only contain unique elements, so any repeated\n        # characters in the word will be eliminated. Then we will get the length of this set to get the number\n        # of unique characters in the word.\n        unique_chars = len(set(word))\n\n        # If the number of unique characters in the current word is more than our current maximum,\n        # we update our maximum and the word.\n        if unique_chars > max_unique_chars:\n            max_unique_chars = unique_chars\n            max_word = word\n\n    # Finally, we return the word with the maximum unique characters.\n    return max_word"}
{"task_id": "HumanEval/159", "completion": "\n\n    # If the remaining carrots are more than or equal to what we need,\n    # we eat the amount we need and the remaining decreases by the amount we eat\n    if remaining >= need:\n        number += need\n        remaining -= need\n    # If the remaining carrots are less than what we need,\n    # we eat all the remaining carrots and the remaining becomes 0\n    else:\n        number += remaining\n        remaining = 0\n\n    # Return the total eaten carrots and the remaining carrots\n    return [number, remaining]"}
{"task_id": "HumanEval/160", "completion": "    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n    \"\"\"\n    expression = \"\"\n    for i in range(len(operator)):\n        expression += str(operand[i]) + operator[i]\n    expression += str(operand[-1])\n    \n    return eval(expression)\n"}
{"task_id": "HumanEval/161", "completion": "\n\n    if not any(c.isalpha() for c in s):\n        return s[::-1]  # reverse the string if no letters are found\n    else:\n        return ''.join([c.upper() if c.islower() else c.lower() for c in s])"}
{"task_id": "HumanEval/162", "completion": "    # Check if the string is empty\n    if not text:\n        return None\n\n    # Create a new md5 hash object\n    md5_hash = hashlib.md5()\n\n    # Encode the string and update the md5 object with the encoded string\n    md5_hash.update(text.encode())\n\n    # Return the hexdigest of the md5 object\n    return md5_hash.hexdigest()"}
{"task_id": "HumanEval/163", "completion": "    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n\n    The previous implementation didn't contain any code. \n    For the current implementation, we first ensure that 'a' is less than 'b'. If not, we swap the numbers. \n    Then we generate the range of numbers from 'a' to 'b' and filter out the even numbers. \n    We return the sorted list of even numbers.\n    \"\"\"\n\n    # check if 'b' is less than 'a', if yes then swap the numbers\n    if b < a:\n        a, b = b, a\n\n    # create list of even numbers from 'a' to 'b'\n    nums = [i for i in range(a, b+1) if i % 2 == 0]\n\n    # return sorted list of even numbers\n    return sorted(nums)\n"}
